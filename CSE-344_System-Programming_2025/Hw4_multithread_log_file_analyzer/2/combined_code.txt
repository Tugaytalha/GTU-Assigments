// Start of buffer.c
#include "buffer.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>

// Initialize the buffer with given capacity
Buffer* buffer_init(int capacity) {
    if (capacity <= 0) {
        return NULL;
    }

    Buffer *buffer = (Buffer*)malloc(sizeof(Buffer));
    if (!buffer) {
        perror("Failed to allocate buffer");
        return NULL;
    }

    buffer->data = (char**)malloc(capacity * sizeof(char*));
    if (!buffer->data) {
        perror("Failed to allocate buffer data");
        free(buffer);
        return NULL;
    }

    buffer->capacity = capacity;
    buffer->size = 0;
    buffer->in = 0;
    buffer->out = 0;
    buffer->eof_reached = false;

    // Initialize synchronization primitives
    if (pthread_mutex_init(&buffer->mutex, NULL) != 0) {
        perror("Failed to initialize buffer mutex");
        free(buffer->data);
        free(buffer);
        return NULL;
    }

    if (pthread_cond_init(&buffer->not_full, NULL) != 0) {
        perror("Failed to initialize not_full condition variable");
        pthread_mutex_destroy(&buffer->mutex);
        free(buffer->data);
        free(buffer);
        return NULL;
    }

    if (pthread_cond_init(&buffer->not_empty, NULL) != 0) {
        perror("Failed to initialize not_empty condition variable");
        pthread_cond_destroy(&buffer->not_full);
        pthread_mutex_destroy(&buffer->mutex);
        free(buffer->data);
        free(buffer);
        return NULL;
    }

    return buffer;
}

// Free all resources used by the buffer
void buffer_destroy(Buffer *buffer) {
    if (!buffer) {
        return;
    }

    // Free all remaining strings in the buffer
    pthread_mutex_lock(&buffer->mutex);
    for (int i = 0; i < buffer->size; i++) {
        int idx = (buffer->out + i) % buffer->capacity;
        if (buffer->data[idx]) {
            free(buffer->data[idx]);
            buffer->data[idx] = NULL;
        }
    }
    pthread_mutex_unlock(&buffer->mutex);

    // Destroy synchronization primitives
    pthread_cond_destroy(&buffer->not_empty);
    pthread_cond_destroy(&buffer->not_full);
    pthread_mutex_destroy(&buffer->mutex);

    // Free buffer data
    free(buffer->data);
    free(buffer);
}

// Add a line to the buffer (used by manager thread)
int buffer_add(Buffer *buffer, char *line) {
    if (!buffer || !line) {
        return -1;
    }

    pthread_mutex_lock(&buffer->mutex);

    // Wait while the buffer is full and we haven't reached EOF
    while (buffer->size == buffer->capacity) {
        pthread_cond_wait(&buffer->not_full, &buffer->mutex);
    }

    // If someone marked EOF while we were waiting, abort
    if (buffer->eof_reached) {
        pthread_mutex_unlock(&buffer->mutex);
        return -1;
    }

    // Add the line to the buffer (make a copy)
    buffer->data[buffer->in] = strdup(line);
    if (!buffer->data[buffer->in]) {
        pthread_mutex_unlock(&buffer->mutex);
        return -1;
    }

    // Update buffer state
    buffer->in = (buffer->in + 1) % buffer->capacity;
    buffer->size++;

    // Signal that the buffer is not empty anymore
    pthread_cond_signal(&buffer->not_empty);
    pthread_mutex_unlock(&buffer->mutex);

    return 0;
}

// Mark the buffer as having reached EOF (no more lines will be added)
void buffer_mark_eof(Buffer *buffer) {
    if (!buffer) {
        return;
    }

    pthread_mutex_lock(&buffer->mutex);
    buffer->eof_reached = true;
    
    // Signal all waiting consumers that EOF has been reached
    pthread_cond_broadcast(&buffer->not_empty);
    pthread_mutex_unlock(&buffer->mutex);
}

// Get a line from the buffer (used by worker threads)
char* buffer_remove(Buffer *buffer) {
    if (!buffer) {
        return NULL;
    }

    pthread_mutex_lock(&buffer->mutex);

    // Wait while the buffer is empty and EOF has not been reached
    while (buffer->size == 0 && !buffer->eof_reached) {
        pthread_cond_wait(&buffer->not_empty, &buffer->mutex);
    }

    // If buffer is empty and EOF has been reached, we're done
    if (buffer->size == 0 && buffer->eof_reached) {
        pthread_mutex_unlock(&buffer->mutex);
        return NULL;
    }

    // Get the line from the buffer
    char *line = buffer->data[buffer->out];
    buffer->data[buffer->out] = NULL;

    // Update buffer state
    buffer->out = (buffer->out + 1) % buffer->capacity;
    buffer->size--;

    // Signal that the buffer is not full anymore
    pthread_cond_signal(&buffer->not_full);
    pthread_mutex_unlock(&buffer->mutex);

    return line;
}

// Check if we've reached EOF and the buffer is empty
bool buffer_is_done(Buffer *buffer) {
    if (!buffer) {
        return true;
    }

    pthread_mutex_lock(&buffer->mutex);
    bool done = (buffer->eof_reached && buffer->size == 0);
    pthread_mutex_unlock(&buffer->mutex);

    return done;
}

// End of buffer.c

// Start of buffer.h
#ifndef BUFFER_H
#define BUFFER_H

#include <pthread.h>
#include <stdbool.h>

// Define a structure for our bounded buffer
typedef struct {
    char **data;           // Array of strings (lines from the log file)
    int capacity;          // Maximum capacity of the buffer
    int size;              // Current number of items in the buffer
    int in;                // Index for next producer insert
    int out;               // Index for next consumer remove
    bool eof_reached;      // Flag to indicate end of file processing
    pthread_mutex_t mutex; // Mutex for buffer access
    pthread_cond_t not_full;   // Condition variable for buffer not full
    pthread_cond_t not_empty;  // Condition variable for buffer not empty
} Buffer;

// Initialize the buffer with given capacity
Buffer* buffer_init(int capacity);

// Free all resources used by the buffer
void buffer_destroy(Buffer *buffer);

// Add a line to the buffer (used by manager thread)
// Returns 0 on success, -1 on error
int buffer_add(Buffer *buffer, char *line);

// Mark the buffer as having reached EOF (no more lines will be added)
void buffer_mark_eof(Buffer *buffer);

// Get a line from the buffer (used by worker threads)
// Returns NULL if EOF and buffer is empty
char* buffer_remove(Buffer *buffer);

// Check if we've reached EOF and the buffer is empty
bool buffer_is_done(Buffer *buffer);

#endif // BUFFER_H

// End of buffer.h

// Start of main.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#ifdef _WIN32
#include <io.h>
#define F_OK 0
#define access _access
#else
#include <unistd.h>
#endif
#include <errno.h>
#include "buffer.h"
#include "utils.h"

#define MAX_LINE_LENGTH 4096

// Worker thread argument structure
typedef struct {
    int thread_id;
    Buffer *buffer;
    char *search_term;
    int match_count;
    pthread_barrier_t *barrier;
} WorkerArgs;

// Global total match count for summary
static int total_matches = 0;
static pthread_mutex_t total_mutex = PTHREAD_MUTEX_INITIALIZER;

// Worker thread function
void* worker_thread(void *arg) {
    WorkerArgs *args = (WorkerArgs*)arg;
    char *line;
    int local_matches = 0;

    while (!exit_flag) {
        // Get a line from the buffer
        line = buffer_remove(args->buffer);
        
        // If NULL returned, we've reached EOF and buffer is empty
        if (line == NULL) {
            break;
        }

        // Search for the term in the line
        if (strstr(line, args->search_term) != NULL) {
            local_matches++;
        }

        // Free the line (we own it now)
        free(line);
    }

    // Save our match count
    args->match_count = local_matches;

    // Add to total count (protected by mutex)
    pthread_mutex_lock(&total_mutex);
    total_matches += local_matches;
    pthread_mutex_unlock(&total_mutex);

    // Print individual worker results
    printf("Worker %d found %d matches\n", args->thread_id, local_matches);

    // Wait at barrier for all threads to finish
    pthread_barrier_wait(args->barrier);

    // Thread 0 is responsible for printing the summary
    if (args->thread_id == 0) {
        printf("\n--- Summary Report ---\n");
        printf("Total matches found: %d\n", total_matches);
        printf("---------------------\n");
    }

    return NULL;
}

// Main function (manager thread)
int main(int argc, char *argv[]) {
    // Parse command line arguments
    ProgramArgs args;
    if (!parse_arguments(argc, argv, &args)) {
        return EXIT_FAILURE;
    }

    // Set up signal handling for SIGINT
    setup_signal_handling();

    // Print program parameters
    printf("Analyzing log file: %s\n", args.log_file);
    printf("Buffer size: %d\n", args.buffer_size);
    printf("Number of workers: %d\n", args.num_workers);
    printf("Search term: \"%s\"\n\n", args.search_term);

    // Initialize the shared buffer
    Buffer *buffer = buffer_init(args.buffer_size);
    if (!buffer) {
        fprintf(stderr, "Failed to initialize buffer\n");
        return EXIT_FAILURE;
    }

    // Set up barrier for worker synchronization
    pthread_barrier_t barrier;
    if (pthread_barrier_init(&barrier, NULL, args.num_workers) != 0) {
        perror("Failed to initialize barrier");
        buffer_destroy(buffer);
        return EXIT_FAILURE;
    }

    // Create worker thread arguments and threads
    pthread_t *workers = (pthread_t*)malloc(args.num_workers * sizeof(pthread_t));
    WorkerArgs *worker_args = (WorkerArgs*)malloc(args.num_workers * sizeof(WorkerArgs));
    
    if (!workers || !worker_args) {
        perror("Failed to allocate memory for workers");
        if (workers) free(workers);
        if (worker_args) free(worker_args);
        pthread_barrier_destroy(&barrier);
        buffer_destroy(buffer);
        return EXIT_FAILURE;
    }

    // Initialize and create worker threads
    for (int i = 0; i < args.num_workers; i++) {
        worker_args[i].thread_id = i;
        worker_args[i].buffer = buffer;
        worker_args[i].search_term = args.search_term;
        worker_args[i].match_count = 0;
        worker_args[i].barrier = &barrier;

        int rc = pthread_create(&workers[i], NULL, worker_thread, &worker_args[i]);
        if (rc != 0) {
            fprintf(stderr, "Failed to create worker thread %d: %s\n", i, strerror(rc));
            
            // Cleanup and exit
            buffer_mark_eof(buffer);  // Signal EOF to any running threads
            
            // Wait for created threads to finish
            for (int j = 0; j < i; j++) {
                pthread_join(workers[j], NULL);
            }
            
            free(workers);
            free(worker_args);
            pthread_barrier_destroy(&barrier);
            buffer_destroy(buffer);
            return EXIT_FAILURE;
        }
    }

    // Manager thread: read the file and fill the buffer
    FILE *file = fopen(args.log_file, "r");
    if (!file) {
        perror("Failed to open log file");
        
        // Signal EOF and clean up
        buffer_mark_eof(buffer);
        
        for (int i = 0; i < args.num_workers; i++) {
            pthread_join(workers[i], NULL);
        }
        
        free(workers);
        free(worker_args);
        pthread_barrier_destroy(&barrier);
        buffer_destroy(buffer);
        return EXIT_FAILURE;
    }

    // Read file line by line
    char line[MAX_LINE_LENGTH];
    while (!exit_flag && fgets(line, sizeof(line), file) != NULL) {
        // Remove newline character if present
        size_t len = strlen(line);
        if (len > 0 && line[len-1] == '\n') {
            line[len-1] = '\0';
        }
        
        // Add line to buffer
        if (buffer_add(buffer, line) != 0) {
            if (exit_flag) {
                break;  // If we're exiting, this is expected
            } else {
                fprintf(stderr, "Failed to add line to buffer\n");
                break;
            }
        }
    }

    // Mark EOF in buffer
    buffer_mark_eof(buffer);
    fclose(file);

    // Wait for all worker threads to finish
    for (int i = 0; i < args.num_workers; i++) {
        pthread_join(workers[i], NULL);
    }

    // Clean up resources
    free(workers);
    free(worker_args);
    pthread_barrier_destroy(&barrier);
    buffer_destroy(buffer);
    pthread_mutex_destroy(&total_mutex);

    return EXIT_SUCCESS;
}

// End of main.c

// Start of utils.c
#include "utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#ifdef _WIN32
#include <io.h>
#define F_OK 0
#define access _access
#else
#include <unistd.h>
#endif

// Global flag that will be set when SIGINT is received
volatile sig_atomic_t exit_flag = 0;

// Signal handler for SIGINT
static void handle_sigint(int sig) {
    exit_flag = 1;
}

// Set up signal handling for SIGINT
void setup_signal_handling() {
    struct sigaction sa;
    memset(&sa, 0, sizeof(sa));
    sa.sa_handler = handle_sigint;
    sigaction(SIGINT, &sa, NULL);
}

// Print usage information
void print_usage(const char *program_name) {
    fprintf(stderr, "Usage: %s <buffer_size> <num_workers> <log_file> <search_term>\n", 
            program_name ? program_name : "./LogAnalyzer");
}

// Parse command line arguments
bool parse_arguments(int argc, char *argv[], ProgramArgs *args) {
    if (!args) {
        return false;
    }

    // Check if we have the right number of arguments
    if (argc != 5) {
        print_usage(argv[0]);
        return false;
    }

    // Parse buffer size
    char *endptr;
    args->buffer_size = (int)strtol(argv[1], &endptr, 10);
    if (*endptr != '\0' || args->buffer_size <= 0) {
        fprintf(stderr, "Error: Buffer size must be a positive integer\n");
        print_usage(argv[0]);
        return false;
    }

    // Parse number of workers
    args->num_workers = (int)strtol(argv[2], &endptr, 10);
    if (*endptr != '\0' || args->num_workers <= 0) {
        fprintf(stderr, "Error: Number of workers must be a positive integer\n");
        print_usage(argv[0]);
        return false;
    }

    // Check if log file exists and is readable
    args->log_file = argv[3];
    if (access(args->log_file, R_OK) != 0) {
        fprintf(stderr, "Error: Cannot access log file '%s'\n", args->log_file);
        print_usage(argv[0]);
        return false;
    }

    // Get search term
    args->search_term = argv[4];
    if (strlen(args->search_term) == 0) {
        fprintf(stderr, "Error: Search term cannot be empty\n");
        print_usage(argv[0]);
        return false;
    }

    return true;
}

// End of utils.c

// Start of utils.h
#ifndef UTILS_H
#define UTILS_H

#include <stdbool.h>
#include <signal.h>

// Structure to hold program arguments
typedef struct {
    int buffer_size;
    int num_workers;
    char *log_file;
    char *search_term;
} ProgramArgs;

// Parse command line arguments into program args structure
// Returns true if arguments are valid, false otherwise
bool parse_arguments(int argc, char *argv[], ProgramArgs *args);

// Print usage information to stderr
void print_usage(const char *program_name);

// Set up signal handling (for SIGINT)
void setup_signal_handling();

// Global flag to tell threads to exit gracefully
extern volatile sig_atomic_t exit_flag;

#endif // UTILS_H

// End of utils.h

